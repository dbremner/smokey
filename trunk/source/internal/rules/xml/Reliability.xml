<!-- Fragile code -->
<Violations>
	<Violation checkID = "R1000" severity = "Error" breaking = "false">
		<Translation lang = "en" typeName = "DisposableFields" category = "Reliability">			
			<Cause>
			A class news IDisposable fields but is not itself IDisposable.
			</Cause>
	
			<Description>
			Classes implement IDisposable so that they can cleanup unmanaged resources in
			a timely manner. But if a field is an IDisposable and the class it's within is
			not then this won't happen.
			</Description>
	
			<Fix>
			The class should implement IDisposable.
			</Fix>
	
			<CSharp>
			using System.IO;

			internal sealed class Log : IDisposable
			{
				public Log()
				{
					m_writer = new StringWriter();
				}
			
				public void WriteLine(string line)
				{
					// All public methods (except Dispose) should throw 
					// ObjectDisposedException if Dispose has been called.
					if (m_disposed)		
						throw new ObjectDisposedException(GetType().Name);
						
					m_writer.WriteLine(line);
				}
			
				// Note that this is a simplified version of the disposable pattern because
				// we have no unmanaged resources.
				public void Dispose()
				{
					if (!m_disposed)
					{
						m_writer.Dispose();
						
						m_disposed = true;
					}
				}
									
				private StringWriter m_writer;	// System.IO.StringWriter implements IDisposable
				private bool m_disposed = false;
			}			
			</CSharp>
		</Translation>
	</Violation>
	
	<Violation checkID = "R1001" severity = "Error" breaking = "false">
		<Translation lang = "en" typeName = "DisposeNativeResources" category = "Reliability">			
			<Cause>
			A class owns an IntPtr or HandleRef field but does not have a finalizer and
			does not implement IDisposable.
			</Cause>
	
			<Description>
			The CLR cannot cleanup unmanaged resources so you need to ensure that they are
			cleaned up yourself.
			</Description>
	
			<Fix>
			The preferred way to handle this is to use a SafeHandle instead of an unwrapped
			unmanaged type. Failing that implement the IDisposable pattern.
			</Fix>
	
			<CSharp>
			internal sealed class SealedWithFinalizer : IDisposable
			{ 
				~SealedWithFinalizer()
				{
					// Note that this is called even if the ctor throws. Also
					// note that this will execute within a worker thread.
					Dispose(false);
				}
				
				public SealedWithFinalizer()
				{
					// allocate resources
				}
				
				public void Work()
				{
					if (m_disposed)		
						throw new ObjectDisposedException(GetType().Name);
				}
			
				public void Dispose()
				{
					Dispose(true);
					GC.SuppressFinalize(this);
				}
				
				private void Dispose(bool disposing)
				{
					if (!m_disposed)
					{
						if (disposing)
						{
							// This code will execute if we were called from Dispose()
							// so we can call methods on our managed fields.
						}
										
						// There are only very weak guarantees on the order in which
						// finalizers are called so we should not use any managed
						// objects here unless we are sure that they (and all objects 
						// they may use) are not finalizeable. Note that System.Console
						// may be used.
						m_disposed = true;
					}
				}
				
				// resource fields go here
				private bool m_disposed; 
			}
			</CSharp>
		</Translation>
	</Violation>	
		
	<!-- gap -->
	
	<Violation checkID = "R1004" severity = "Warning" breaking = "false">
		<Translation lang = "en" typeName = "DisposeScopedObjects" category = "Reliability">			
			<Cause>
			A method created an IDisposable local variable but did not dispose of it.
			</Cause>
	
			<Description>
			IDisposable is used for objects containing unmanaged resources that have to
			be cleaned up in a timely manner. If you don't explicitly dispose of them
			they are cleaned up by the garbage collector which may not run for quite some
			time.
			</Description>
	
			<Fix>
			Use a using statement to ensure that the object is disposed even in the
			presence of exceptions.
			</Fix>
	
			<CSharp>
			using System.IO;

			internal static class Utils
			{
				public static string ReadAll(string path)
				{
					string text;
					
					using (StreamReader stream = new StreamReader(path)) 
					{
						text = stream.ReadToEnd();
					}
					
					return text;
				}
			}			
			</CSharp>
		</Translation>
	</Violation>	
	
	<Violation checkID = "R1005" severity = "Warning" breaking = "true">
		<Translation lang = "en" typeName = "CtorCallsVirtual" category = "Reliability">			
			<Cause>
			A constructor is calling an unsealed virtual method.
			</Cause>
	
			<Description>
			If a constructor calls a virtual method which is overridden in a derived class
			the method in the derived class is called. However the derived classes constructor
			won't have been called yet. This will often be unexpected behavior and makes
			it very easy for maintainers to introduce bugs if they change the derived method.
			</Description>
	
			<Fix>
			Seal the method, seal the class, or call the method somewhere else.
			</Fix>
	
			<CSharp>
			internal abstract class Animal
			{
				public abstract string Description
				{
					get;
				}
				
				public abstract string Species
				{
					get;
				}
			}			

			internal sealed class Dog : Animal
			{
				public Dog(string breed)
				{
					// Call to Species is OK because the property is sealed.
					m_descripion = string.Format("{0} ({1})", breed, Species);
				}
				
				public override string Description
				{
					get {return m_descripion;}
				}
				
				public sealed override string Species
				{
					get {return "Canis lupus familiaris";}
				}
				
				private string m_descripion;
			}			
			</CSharp>
		</Translation>
	</Violation>	
	
	<!-- gap -->
	
	<Violation checkID = "R1009" severity = "Warning" breaking = "false">
		<Translation lang = "en" typeName = "CompareFloats" category = "Reliability">			
			<Cause>
			A method is comparing floating point numbers for equality.
			</Cause>
		
			<Description>
			Floating point numbers are very precise, but they are not necessarily
			accurate. Because of the way the hardware implements floating point
			numbers they are almost always approximations of real values and errors
			accumulate as operations are performed on them. Because of this it's
			almost always wrong to compare a floating point number to a finite value.
			Note that not equal tests have the same problem because they will almost
			always be true.
			</Description>
	
			<Fix>
			The simplest fix is to check to see if the two numbers are close to each
			other. Something like this: Math.Abs(x - y) &lt; 0.001. However this won't
			work if the typical values are very large (because the delta will be large)
			or very small (because the delta will be too small). For a safer alternative
			see the code below. Also see &lt;http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm&gt;.
			</Fix>
	
			<CSharp>
			using System.Diagnostics;
			
			public static class DoubleExtensions
			{
				// Returns true if the two floating point numbers are close to each other.
				public static bool NearlyEquals(this double x, double y)
				{
					return x.NearlyEquals(y, 1.0e-6);
				}
			
				// Comparing floating point numbers for equality is tricky because the 
				// limited precision of the hardware introduces small errors so that two 
				// numbers that should compare equal don't. So what we do is consider the 
				// numbers equal if their difference is less than some epsilon value. But 
				// choosing this epsilon is also tricky because if the numbers are large 
				// epsilon should also be large, and if the numbers are very small the 
				// epsilon must be even smaller. To get around this we'll use a technique 
				// from Knuth's "Seminumerical Algorithms" section 4.2.2 and scale epsilon 
				// by the exponent of one of the specified numbers. 
				public static bool NearlyEquals(this double x, double y, double epsilon)
				{
					Debug.Assert(epsilon &gt;= 0.0);
								
					// Infinity is an exact value so we can use equals with it.
					if (double.IsInfinity(x) || double.IsInfinity(y))
						return x == y;
					
					// Knuth recommends scaling by the exponent of the smallest number.
					// C has standard functions for breaking apart floating point numbers
					// (frexp) and scaling them (ldexp), but .NET does not. So, we'll
					// scale by a percentage of the smallest value which should give
					// us very similar results.
					double scaling = 0.75 * Math.Min(Math.Abs(x), Math.Abs(y));
						
					// If we of our numbers is exactly zero then we cannot use an
					// extremely small scaled epsilon or numbers will never compare
					// equal to zero. So, we do like Knuth, and use whatever epsilion
					// was passed in.
					double delta = scaling != 0.0 ? epsilon * scaling : epsilon;
					
					// If the difference between the numbers is smaller than the scaled
					// epsilon we'll consider the numbers to be equal.
					double difference = Math.Abs(x - y);
					bool equal = difference &lt;= delta;
					
					return equal;
				}
			}
			</CSharp>
		</Translation>
	</Violation>	
	
	<!-- gap -->
	
	<Violation checkID = "R1011" severity = "Error" breaking = "false">
		<Translation lang = "en" typeName = "ConsistentEquality" category = "Reliability">			
			<Cause>
			Equals, operator==, operator!=, CompareTo, and/or GetHashCode are using different
			fields and properties.
			</Cause>
		
			<Description>
			If two objects compare equal with one equality method then they should compare
			equal with the other equality methods. Similarly two objects that compare
			equal should have the same hash code.
			</Description>
	
			<Fix>
			Fix the code so that the equals methods and GetHashCode are using the same
			fields and properties. If there's a valid reason for accessing a field or
			property in one method, but not all of them, you can avoid the error by
			using a helper method to do the comparison.
			</Fix>
		</Translation>
	</Violation>	
		
	<Violation checkID = "R1012" severity = "Error" breaking = "false">
		<Translation lang = "en" typeName = "ObjectHashCode" category = "Reliability">			
			<Cause>
			A class defines Equals or operator== and checks state, but does not override 
			GetHashCode or calls Object::GetHashCode in the override.
			</Cause>
		
			<Description>
			The Object::GetHashCode uses the object's address to compute the hash code.
			This works well with the default Equals which is also based on addresses, but
			does not work if you change the behavior of Equals because two objects that
			compare equal must have the same hash.
			</Description>
	
			<Fix>
			Override GetHashCode and hash the fields that Equals checks. Do not call 
			Object::GetHashCode.
			</Fix>
	
			<CSharp>
			internal sealed class Customer : IEquatable&lt;Customer&gt;
			{		
				public override bool Equals(object rhsObj)
				{
					if (rhsObj == null)			// as is a little expensive, so skip it if we can
						return false;
					
					Customer rhs = rhsObj as Customer;
					return this == rhs;
				}
					
				public bool Equals(Customer rhs)	// provide a typed overload for efficiency
				{
					return this == rhs;
				}

				public static bool operator==(Customer lhs, Customer rhs)
				{
					// If both are null, or both are the same instance, return true.
					if (object.ReferenceEquals(lhs, rhs))
						return true;
					
					// If one is null, but not both, return false.
					if ((object) lhs == null || (object) rhs == null)
						return false;
					
					// Return true if the fields match:
					return lhs.name == rhs.name &amp;&amp; lhs.address == rhs.address;
				}
				
				public static bool operator!=(Customer lhs, Customer rhs)
				{
					return !(lhs == rhs);
				}
				
				public override int GetHashCode()
				{
					int hash;
					
					unchecked
					{
						hash = name.GetHashCode() + address.GetHashCode();
					}
					
					return hash;
				}

				private string name = "ted";
				private string address = "main street";
			}
			</CSharp>
		</Translation>
	</Violation>	
		
	<Violation checkID = "R1013" severity = "Error" breaking = "false">
		<Translation lang = "en" typeName = "WeakIdentityLock" category = "Reliability">			
			<Cause>
			A method locks an object with weak identity.
			</Cause>
		
			<Description>
			An object with weak identity is an object that can be directly accessed from
			different application domains. Locking an object with weak identity means
			that threads in one application domain can be blocked by threads from another
			domain which is unexpected to say the least. The classes with weak identity are:
			* System.MarshalByRefObject
			* System.ExecutionEngineException
			* System.OutOfMemoryException
			* System.StackOverflowException
			* System.String
			* System.Reflection.MemberInfo
			* System.Reflection.ParameterInfo
			* System.Threading.Thread
			</Description>
	
			<Fix>
			Pick something else to lock.
			</Fix>
			
			<CSharp>
			internal sealed class Engine
			{
				public void Work()
				{
					lock (m_lock)
					{
						DoWork();
					}
				}
				
				private static void DoWork()
				{
					Console.WriteLine("working...");
				}
				
				private object m_lock = new object();
			}			
			</CSharp>
		</Translation>
	</Violation>	
	
	<Violation checkID = "R1014" severity = "Warning" breaking = "true">
		<Translation lang = "en" typeName = "StaticSetter" category = "Reliability">			
			<Cause>
			A non-private static method which sets state and has no locking is called 
			from a thread.
			</Cause>
	
			<Description>
			A non-private static method can be called from anywhere so there is no way
			for callers to guarantee that any writes it does are serialized.
			</Description>
	
			<Fix>
			Don't use a static method or have the method lock.
			</Fix>
	
			<CSharp>
			internal static class Storage
			{
				public static void Update(string text)
				{
					lock (ms_lock)
					{
						// Copying a reference is guaranteed to be atomic as long as the field is
						// aligned (which it will be if you're using the default AutoLayout). But
						// to guarantee that our write is immediately visible to other threads we
						// need to either use a lock or something like Interlocked.Exchange. See
						// &lt;http://discuss.develop.com/archives/wa.exe?A2=ind0203B&amp;L=DOTNET&amp;P=R375&gt;
						// and &lt;http://blogs.msdn.com/cbrumme/archive/2003/05/17/51445.aspx&gt; for 
						// more details.
						ms_text = text;
					}
				}
				
				public static string Text
				{
					get {return ms_text;}
				}
				
				private static object ms_lock = new object();
				private static string ms_text = string.Empty;
			}			
			</CSharp>
		</Translation>
	</Violation>	
	
	<Violation checkID = "R1015" severity = "Warning" breaking = "false">
		<Translation lang = "en" typeName = "STAThread" category = "Reliability">			
			<Cause>
			The assembly references System.Windows.Forms but the main entry point does 
			not have STAThreadAttribute.
			</Cause>
	
			<Description>
			STAThreadAttribute tells the runtime that the main thread is using the single
			threaded apartment model. This is required on Windows in order to interoperate
			with COM which is used by the clipboard, file dialogs, and drag and drop.
			</Description>
	
			<Fix>
			Use STAThread.
			</Fix>
	
			<CSharp>
			internal static class Program
			{
				[STAThread]
				public static int Main(string[] args)
				{ 
					Console.WriteLine("hello world");
					
					return 0;
				}
			}
			</CSharp>
		</Translation>
	</Violation>	
	
	<Violation checkID = "R1016" severity = "Warning" breaking = "true">
		<Translation lang = "en" typeName = "Const2" category = "Reliability">			
			<Cause>
			A externally visible field is declared const.
			</Cause>
		
			<Description>
			The value for const fields is baked into the assemblies metadata. When another
			assembly is compiled which refers to that field the value of the field is used
			instead of the name. This means that changing the value of the constant will
			not affect other assemblies unless they are recompiled.
			</Description>
	
			<Fix>
			Use a static readonly field unless you're sure that the value of the constant
			will never change.
			</Fix>
		</Translation>
	</Violation>	
	
	<Violation checkID = "R1017" severity = "Error" breaking = "false">
		<Translation lang = "en" typeName = "BaseSerializable1" category = "Reliability">			
			<Cause>
			An externally visible type derives from a type that implements System.Runtime.Serialization.ISerializable,
			has a constructor with (SerializationInfo, StreamingContext)
			arguments, but does not call the base serialization constructor.
			</Cause>
		
			<Description>
			The constructor must call the base constructor to ensure that the base fields
			are properly serialized.
			</Description>
	
			<Fix>
			Call the base constructor.
			</Fix>
	
			<CSharp>
			using System.Runtime.Serialization;
			using System.Security.Permissions;
			
			[Serializable]
			public class BaseType : ISerializable
			{
				public BaseType()
				{
					m_baseValue = 3;
				}
				
				protected BaseType(SerializationInfo info, StreamingContext context)
				{
					m_baseValue = info.GetInt32("m_baseValue");
				}
				
				[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
				public virtual void GetObjectData(SerializationInfo info, StreamingContext context)
				{
					info.AddValue("baseValue", m_baseValue);
				}
				
				private int m_baseValue;
			}
				
			[Serializable]
			public class DerivedType : BaseType
			{
				public DerivedType()
				{
					m_derivedValue = 4;
				}
				
				protected DerivedType(SerializationInfo info, StreamingContext context) : 
					base(info, context)
				{
					m_derivedValue = info.GetInt32("derivedValue");
				}
				
				[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
				public override void GetObjectData(SerializationInfo info, StreamingContext context)
				{
					info.AddValue("derivedValue", m_derivedValue);
					base.GetObjectData(info, context);
				}
				
				private int m_derivedValue;
			}
			</CSharp>
		</Translation>
	</Violation>	
	
	<Violation checkID = "R1018" severity = "Error" breaking = "false">
		<Translation lang = "en" typeName = "BaseSerializable2" category = "Reliability">			
			<Cause>
			An externally visible type derives from a type that implements System.Runtime.Serialization.ISerializable,
			has a GetObjectData(SerializationInfo, StreamingContext) method, but does not
			call the base GetObjectData.
			</Cause>
		
			<Description>
			GetObjectData must call the base GetObjectData to ensure that the base fields
			are properly serialized.
			</Description>
	
			<Fix>
			Call the base GetObjectData.
			</Fix>
	
			<CSharp>
			using System.Runtime.Serialization;
			using System.Security.Permissions;
			
			[Serializable]
			public class BaseType : ISerializable
			{
				public BaseType()
				{
					m_baseValue = 3;
				}
				
				protected BaseType(SerializationInfo info, StreamingContext context)
				{
					m_baseValue = info.GetInt32("m_baseValue");
				}
				
				[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
				public virtual void GetObjectData(SerializationInfo info, StreamingContext context)
				{
					info.AddValue("baseValue", m_baseValue);
				}
				
				private int m_baseValue;
			}
				
			[Serializable]
			public class DerivedType : BaseType
			{
				public DerivedType()
				{
					m_derivedValue = 4;
				}
				
				protected DerivedType(SerializationInfo info, StreamingContext context) : 
					base(info, context)
				{
					m_derivedValue = info.GetInt32("derivedValue");
				}
				
				[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
				public override void GetObjectData(SerializationInfo info, StreamingContext context)
				{
					info.AddValue("derivedValue", m_derivedValue);
					base.GetObjectData(info, context);
				}
				
				private int m_derivedValue;
			}
			</CSharp>
		</Translation>
	</Violation>
	
	<Violation checkID = "R1019" severity = "Error" breaking = "false">
		<Translation lang = "en" typeName = "RequireSerializableCtor" category = "Reliability">			
			<Cause>
			The type implements System.Runtime.Serialization.ISerializable, is not a delegate
			or interface, but does not implement the (SerializationInfo, StreamingContext) 
			constructor.
			</Cause>
		
			<Description>
			In order to be deserialized the type must have a (SerializationInfo, StreamingContext)
			constructor.
			</Description>
	
			<Fix>
			Add the (SerializationInfo, StreamingContext) constructor.
			</Fix>
	
			<CSharp>
			using System.Runtime.Serialization;
			using System.Security.Permissions;
			
			[Serializable]
			public class Customer : ISerializable
			{
				public Customer(string name)
				{
					m_name = name;
				}
				
				// This should be protected for unsealed types, and private for sealed types.
				protected Customer(SerializationInfo info, StreamingContext context)
				{
					m_name = info.GetString("name");
				}
				
				[SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]
				public virtual void GetObjectData(SerializationInfo info, StreamingContext context)
				{
					info.AddValue("name", m_name);
				}
				
				private string m_name;
			}
			</CSharp>
		</Translation>
	</Violation>
	
	<Violation checkID = "R1020" severity = "Error" breaking = "false">
		<Translation lang = "en" typeName = "NonSerializableField" category = "Reliability">			
			<Cause>
			A type is decorated with System.SerializableAttribute, does not implement
			ISerializable, and has an instance field which is not serializable and
			not marked with System.NonSerializedAttribute.
			</Cause>
		
			<Description>
			If the type does not implement ISerializable then it will be serialized using
			reflection on each field. The field types must be decorated with System.SerializableAttribute
			or the fields with System.NonSerializedAttribute. If not a System.Runtime.Serialization.SerializationException
			will be thrown when the type is serialized.
			</Description>
	
			<Fix>
			Decorate the field with System.NonSerializedAttribute, make the field type
			serializable, or implement ISerializable.
			</Fix>
		</Translation>
	</Violation>
	
	<Violation checkID = "R1021" severity = "Warning" breaking = "false">
		<Translation lang = "en" typeName = "RandomUsedOnce" category = "Reliability">			
			<Cause>
			An instance of System.Random is created using the default constructor and
			only one random value is retrieved.
			</Cause>
		
			<Description>
			The random number generator will return poor results when used in this way.
			</Description>
	
			<Fix>
			Create an instance of Random and reuse it to get subsequent values.
			</Fix>
		</Translation>
	</Violation>
	
	<Violation checkID = "R1022" severity = "Warning" breaking = "false">
		<Translation lang = "en" typeName = "IdenticalBranch" category = "Reliability">			
			<Cause>
			A conditional branch has identical code for the taken and not-taken cases.
			</Cause>
		
			<Description>
			This isn't necessarily an error, but it may be a maintenance headache because
			if one branch is changed the other will probably need to change as well.
			</Description>
	
			<Fix>
			Rewrite the code or use DisableRuleAttribute.
			</Fix>
		</Translation>
	</Violation>

	<Violation checkID = "R1023" severity = "Warning" breaking = "false">
		<Translation lang = "en" typeName = "IdenticalCase" category = "Reliability">			
			<Cause>
			Two cases in a switch statement have identical code.
			</Cause>
		
			<Description>
			This isn't necessarily an error, but it may be a maintenance headache because
			if one case is changed the other will probably need to change as well.
			</Description>
	
			<Fix>
			Rewrite the code or use DisableRuleAttribute.
			</Fix>
		</Translation>
	</Violation>

	<Violation checkID = "R1024" severity = "Warning" breaking = "false">
		<Translation lang = "en" typeName = "UncheckedAssembly" category = "Reliability">			
			<Cause>
			The assembly has one or more add instructions but no add.ovf instruction.
			</Cause>
		
			<Description>
			In general you should compile assemblies using the -checked switch so that
			integer arithmetic overflow is detected. If profiling indicates that a method
			is a bottleneck or you're doing something like a hash function for which
			overflow is immaterial then use the unchecked statement.
			</Description>
	
			<Fix>
			Use the -checked command line switch or DisableRuleAttribute.
			</Fix>
	
			<CSharp>
			internal sealed class Vector3
			{		
				public override int GetHashCode()
				{
					int hash;
					
					// The addditions may overflow but we don't care so we use
					// the unchecked statement to ensure that an OverflowException
					// is not thrown.
					unchecked
					{
						hash = X.GetHashCode() + Y.GetHashCode() + Z.GetHashCode();
					}
					
					return hash;
				}
				
				public readonly float X;
				public readonly float Y;
				public readonly float Z;
			}
			</CSharp>
		</Translation>
	</Violation>

	<Violation checkID = "R1025" severity = "Error" breaking = "false">
		<Translation lang = "en" typeName = "HashOverflow" category = "Reliability">			
			<Cause>
			The result of a GetHashCode call is summed with add.ovf.
			</Cause>
		
			<Description>
			GetHashcode can return arbitrarily large values so the result should
			not be summed with the version of add that does overflow checking.
			</Description>
	
			<Fix>
			Use the unchecked statement to ensure the math is done without overflow
			checking.
			</Fix>
	
			<CSharp>
			internal sealed class Vector3
			{		
				public override int GetHashCode()
				{
					int hash;
					
					// The addditions may overflow but we don't care so we use
					// the unchecked statement to ensure that an OverflowException
					// is not thrown.
					unchecked
					{
						hash = X.GetHashCode() + Y.GetHashCode() + Z.GetHashCode();
					}
					
					return hash;
				}
				
				public readonly float X;
				public readonly float Y;
				public readonly float Z;
			}
			</CSharp>
		</Translation>
	</Violation>

	<Violation checkID = "R1026" severity = "Error" breaking = "false">
		<Translation lang = "en" typeName = "AvoidIsAlive" category = "Reliability">			
			<Cause>
			System.WeakReference::IsAlive was used.
			</Cause>
		
			<Description>
			If IsAlive returns true then the object it references has not been garbage
			collected but it may be garbage collected immediately after IsAlive returns
			if another thread releases the last reference to the object. If IsAlive
			returns false the object was definitely collected.
			</Description>
	
			<Fix>
			Use WeakReference::Target instead of IsAlive. Or if you do use IsAlive only
			check for a false result.
			</Fix>
	
			<CSharp>
			using System.Collections.Generic;
			
			// Simple leak checker. Register objects which should be garbage collected
			// and call DumpActive later to see if they were, in fact, collected.
			internal static class ObjectTracker
			{
				public static void Register(object o)
				{ 			
					lock (ms_objects)
					{
						ms_objects.Add(new WeakReference(o));
					}
				}
				
				[DisableRule("P1017", "ExplicitGC")]    
				public static void DumpActive()
				{
					// Force a collection so that everything that can be collected is.
					// Note that we also have to sleep for a bit to give the finalizer
					// thread time to run.
					GC.Collect();		
					System.Threading.Thread.Sleep(200);
			
					// Now we can iterate over all of our objects and see which are
					// still alive. The code uses Target so that we have a strong
					// reference to the object on the stack as soon as Target returns.
					// If we had used IsAlive and Target the object could have been
					// collected between the two calls (e.g. another thread may have
					// removed the last reference to the object).
					lock (ms_objects)
					{
						foreach (WeakReference r in ms_objects)
						{
							object o = r.Target;
							if (o != null)
								Console.WriteLine("{0} is alive", o);
						}
					}
				}
			
				private static List&lt;WeakReference&gt; ms_objects = new List&lt;WeakReference&gt;();
			}
			</CSharp>
		</Translation>
	</Violation>

	<Violation checkID = "R1027" severity = "Warning" breaking = "false">
		<Translation lang = "en" typeName = "UnusualMonitor1" category = "Reliability">			
			<Cause>
			A System.Monitor.Wait was done without a timeout, but the wait is not in a
			loop, or the loop does more than just waiting.
			</Cause>
		
			<Description>
			Writing threaded code can be both difficult and subtle so it's highly
			desirable to stick to the standard monitor pattern.
			</Description>
	
			<Fix>
			Rewrite the code to use the standard monitor pattern. This should usually be
			done even if the code is correct to make it easier for readers of the code
			to verify that it is correct and to ensure that the code works in the future
			if more threads are used. If not, decorate the method with DisableRuleAttribute.
			</Fix>
	
			<CSharp>
			using System.Collections;
			using System.Threading;
			
			internal sealed class ProducerConsumer
			{
				public void Produce(object o)
				{
					lock (m_lock)
					{
						m_queue.Enqueue(o);
						
			            // Pulse when a change is made to our wait predicate.
						// If no thread is waiting then this will be a no-op. By
						// using PulseAll instead of Pulse we can ensure that as
						// many threads as possible wake up to handle the objects
						// we've added (and if only one thread is running Consume
						// PulseAll is no less efficient than Pulse).
						//
						// Similarly we need to pulse even if the queue was non-empty
						// because Consume may have missed the pulse when we first
						// added an item.
						//
						// Note that, unlike pthreads, the lock must be held when
						// Pulse or PulseAll is called.
						Monitor.PulseAll(m_lock);
					}
				}
				
				public object Consume()
				{
					object result = null;
					
					lock (m_lock)
					{
						// Block until we're happy with our wait predicate. If multiple 
						// threads are running Consume then we must use a loop to ensure 
						// another Consume thread hasn't stolen the new object. If Consume 
						// is only run by one thread then we could technically use an if, 
						// but it's better style and less fragile to use a loop anyway.
						while (m_queue.Count == 0)
						{
							// The wait call will release our mutex and wait for a Pulse.
							// When pulsed the mutex will be reacquired and wait will return
							// true (always true because we don't use a timeout).
							Ignore.Value = Monitor.Wait(m_lock);
						}
						
						result = m_queue.Dequeue();
					}
					
					return result;
				}
				
				private object m_lock = new object();
				private Queue m_queue = new Queue();
			}
			</CSharp>
		</Translation>
	</Violation>

	<Violation checkID = "R1028" severity = "Warning" breaking = "false">
		<Translation lang = "en" typeName = "UnusualMonitor2" category = "Reliability">			
			<Cause>
			A System.Monitor.Wait was done with a timeout, but the wait is not in a
			loop.
			</Cause>
		
			<Description>
			Writing threaded code can be both difficult and subtle so it's highly
			desirable to stick to the standard monitor pattern.
			</Description>
	
			<Fix>
			Rewrite the code to use the standard monitor pattern. This should usually be
			done even if the code is correct to make it easier for readers of the code
			to verify that it is correct and to ensure that the code works in the future
			if more threads are used. If not, decorate the method with DisableRuleAttribute.
			</Fix>
	
			<CSharp>
			using System.Collections;
			using System.Threading;
			
			internal sealed class ProducerConsumer
			{
				public void Produce(object o)
				{
					lock (m_lock)
					{
						m_queue.Enqueue(o);
						
			            // Pulse when a change is made to our wait predicate.
						// If no thread is waiting then this will be a no-op. By
						// using PulseAll instead of Pulse we can ensure that as
						// many threads as possible wake up to handle the objects
						// we've added (and if only one thread is running Consume
						// PulseAll is no less efficient than Pulse).
						//
						// Similarly we need to pulse even if the queue was non-empty
						// because Consume may have missed the pulse when we first
						// added an item.
						//
						// Note that, unlike pthreads, the lock must be held when
						// Pulse or PulseAll is called.
						Monitor.PulseAll(m_lock);
					}
				}
				
				public object Consume()
				{
					object result = null;
					
					lock (m_lock)
					{
						// Block until we're happy with our wait predicate. If multiple 
						// threads are running Consume then we must use a loop to ensure 
						// another Consume thread hasn't stolen the new object. If Consume 
						// is only run by one thread then we could technically use an if, 
						// but it's better style and less fragile to use a loop anyway.
						while (m_queue.Count == 0)
						{
							// The wait call will release our mutex and wait for a Pulse.
							// When pulsed the mutex will be reacquired and wait will return
							// true (always true because we don't use a timeout).
							bool pulsed = Monitor.Wait(m_lock, m_timeout);
							
							// It's also possible to use the timeout to work around
							// missed pulses.
							if (!pulsed)
								throw new InvalidOperationException("timed out");
						}
						
						result = m_queue.Dequeue();
					}
					
					return result;
				}
				
				private object m_lock = new object();
				private Queue m_queue = new Queue();
				private TimeSpan m_timeout = TimeSpan.FromSeconds(60);
			}
			</CSharp>
		</Translation>
	</Violation>

	<Violation checkID = "R1029" severity = "Warning" breaking = "false">
		<Translation lang = "en" typeName = "ZeroSleep" category = "Reliability">			
			<Cause>
			System.Threading.Thread.Sleep(0) was used.
			</Cause>
		
			<Description>
			Sleep(0) doesn't allow lower priority threads to run which can lead to 
			priority inversion bugs. See 
			&lt;http://www.bluebytesoftware.com/blog/PermaLink,guid,f8404ab3-e3e6-4933-a5bc-b69348deedba.aspx&gt; 
			for more details.
			</Description>
	
			<Fix>
			Use Sleep(1).
			</Fix>
		</Translation>
	</Violation>

	<Violation checkID = "R1030" severity = "Warning" breaking = "false">
		<Translation lang = "en" typeName = "StringUriOverload" category = "Reliability">			
			<Cause>
			A type has two methods with the same names, the same signatures, except that
			one method uses string for an argument, and the second uses System.Uri for that
			argument. The method that takes a string does not call the method that takes a Uri.
			</Cause>
		
			<Description>
			The string is assumed to be a URI, but the string representation is prone
			to parsing and encoding errors. By converting the string to a URI and calling
			the Uri version of the method you can leverage all of the sanity checking code
			in Uri and avoid potential security vulnerabilities.
			</Description>
	
			<Fix>
			Change the string method to call the Uri method, or disable the rule by
			decorating the type with DisableRuleAttribute.
			</Fix>
		</Translation>
	</Violation>

	<Violation checkID = "R1031" severity = "Warning" breaking = "false">
		<Translation lang = "en" typeName = "StringUri1" category = "Reliability">			
			<Cause>
			A type declares a method one of whose decomposed argument names
			has a component named "uri", "Uri", "urn", "Urn", "url", or "Url", but there
			is no corresponding overload that takes a System.Uri for that argument position.
			The decomposition splits the argument name based on case changes (so "inUri"
			becomes ["in", "Uri"]).
			</Cause>
		
			<Description>
			The string is assumed to be a URI, but the string representation is prone
			to parsing and encoding errors. By using a URI you can leverage all of the 
			sanity checking code in Uri and avoid potential security vulnerabilities.
			</Description>
	
			<Fix>
			Change the argument type to a System.Uri or add an overload with a System.Uri
			argument and call it from the original method, or disable the rule by
			decorating the type with DisableRuleAttribute.
			</Fix>
		</Translation>
	</Violation>

	<Violation checkID = "R1032" severity = "Warning" breaking = "true">
		<Translation lang = "en" typeName = "StringUri2" category = "Reliability">			
			<Cause>
			A type declares a property of type string and the decomposed property name
			has a component named "uri", "Uri", "urn", "Urn", "url", or "Url".
			The decomposition splits the argument name based on case changes (so "inUri"
			becomes ["in", "Uri"]).
			</Cause>
		
			<Description>
			The string is assumed to be a URI, but the string representation is prone
			to parsing and encoding errors. By using a URI you can leverage all of the 
			sanity checking code in Uri and avoid potential security vulnerabilities.
			</Description>
	
			<Fix>
			Change the property type to a System.Uri, or disable the rule by
			decorating the type with DisableRuleAttribute.
			</Fix>
		</Translation>
	</Violation>

	<Violation checkID = "R1033" severity = "Warning" breaking = "true">
		<Translation lang = "en" typeName = "StringUri3" category = "Reliability">			
			<Cause>
			A decomposed name of a method
			has a component named "uri", "Uri", "urn", "Urn", "url", or "Url" and the
			method returns System.String.
			The decomposition splits the argument name based on case changes (so "inUri"
			becomes ["in", "Uri"]).
			</Cause>
		
			<Description>
			The string is assumed to be a URI, but the string representation is prone
			to parsing and encoding errors. By using a URI you can leverage all of the 
			sanity checking code in Uri and avoid potential security vulnerabilities.
			</Description>
	
			<Fix>
			Change the method so that it returns a System.Uri, or disable the rule by
			decorating the method with DisableRuleAttribute.
			</Fix>
		</Translation>
	</Violation>

	<Violation checkID = "R1034" severity = "Warning" breaking = "false">
		<Translation lang = "en" typeName = "ValidateArgs1" category = "Reliability">			
			<Cause>
			An externally visible method has a reference argument, and a method on that
			argument is called without first comparing the argument against null.
			</Cause>
		
			<Description>
			A method can be thought of as having a (possibly implicit) contract between
			itself and its caller. The method guarantees that it will do its job when
			called correctly. To check that the contract isn't violated the method
			verifies its arguments and possibly other state when it is entered, if all
			is well it then does its work, and on exit verifies that its work was done.
			See &lt;http://archive.eiffel.com/doc/manuals/technology/contract/&gt; for
			more details.
			
			Normally an exception should be thrown if a reference argument is null so
			that the error can be caught as soon as possible and so that the source of
			the error can be clearly identified. If it may be null there should still
			be a test against null before calling a method on the argument.
			</Description>
	
			<Fix>
			Use a custom assert method, use an if statement and ArgumentNullException, or
			use System.Diagnostics.Debug.Assert (although this last one is iffy because
			it's compiled out in release).
			</Fix>
	
			<CSharp>
			using System.Collections.Generic;
			using System.Diagnostics;
			using System.Runtime.Serialization;
			
			public static class ListExtensions 
			{
				// This is the way arguments are usually checked.
				public static T Back1&lt;T&gt;(this List&lt;T&gt; list) 
				{ 
					if (list == null)
						throw new ArgumentNullException("list");
					
					if (list.Count == 0)
						throw new ArgumentException("list is empty");
					
					return list[list.Count - 1];
				} 
			
				// Some people do this, but the checks are compiled out in release
				// which is especially bad for externally visible methods.
				public static T Back2&lt;T&gt;(this List&lt;T&gt; list) 
				{ 
					Debug.Assert(list != null, "list is null");
					Debug.Assert(list.Count &gt; 0, "list is empty");
					
					return list[list.Count - 1];
				} 
			
				// This uses custom assert methods which are not compiled out in
				// release (see below).
				public static T Back3&lt;T&gt;(this List&lt;T&gt; list) 
				{ 
					DBC.Pre(list != null, "list is null");
					DBC.Pre(list.Count &gt; 0, "list is empty");
					
					return list[list.Count - 1];
				} 
			}
			
			// --------------------------------------------------------
			
			/// &lt;summary&gt;Thrown by Dbc.Assert and FastAssert.&lt;/summary&gt;
			public class AssertException : Exception
			{
				public AssertException(string text) : base(text) 
				{
				}
			
				protected AssertException(SerializationInfo info, StreamingContext context) : base(info, context)
				{
				}
			}
			
			/// &lt;summary&gt;Thrown by Dbc.Pre and FastPre.&lt;/summary&gt;
			public class PreconditionException : AssertException
			{
				public PreconditionException(string text) : base(text) 
				{
				}
			
				protected PreconditionException(SerializationInfo info, StreamingContext context) : base(info, context)
				{
				}
			}
			
			/// &lt;summary&gt;Thrown by Dbc.Post and FastPost.&lt;/summary&gt;
			public class PostconditionException : AssertException
			{
				public PostconditionException(string text) : base(text) 
				{
				}
			
				protected PostconditionException(SerializationInfo info, StreamingContext context) : base(info, context)
				{
				}
			}
			
			/// &lt;summary&gt;Asserts used to verify the contract between the caller of
			/// a method and the method.&lt;/summary&gt;
			///
			/// &lt;remarks&gt;&lt;para&gt;In the Design By Contract methodology methods act as a contract 
			/// between the caller of the method and the method itself. The client guarantees
			/// to call the method correctly and the method guarantees to some work
			/// if called correctly (or throw an exception if it is unable to do so).&lt;/para&gt;
			///
			/// &lt;para&gt;The client side of the contract is checked by the Dbc.Pre methods. The
			/// method side of the contract is checked with Dbc.Post methods. The Dbc.
			/// Assert methods can be used to verify that the state of the world is as
			/// expected within a method. There are also Fast versions of these methods
			/// which are compiled out in release. These should only be used for code
			/// that is known to be time critical.&lt;/para&gt;
			///
			/// &lt;para&gt;Dbc also makes use of invariants, but these are outside the scope of the
			/// Dbc class. See http://archive.eiffel.com/doc/manuals/technology/contract/
			/// for more details.&lt;/para&gt;&lt;/remarks&gt;
			public static class Dbc
			{		
				public static void Pre(bool f, string s)									{if (!f) throw new PreconditionException(s);}
				public static void Pre&lt;A1&gt;(bool f, string format, A1 arg1)					{if (!f) throw new PreconditionException(string.Format(format, arg1));}
				public static void Pre&lt;A1, A2&gt;(bool f, string format, A1 arg1, A2 arg2)		{if (!f) throw new PreconditionException(string.Format(format, arg1, arg2));}
				public static void Pre(bool f, string format, params object[] args)			{if (!f) throw new PreconditionException(string.Format(format, args));}
			
				public static void Post(bool f, string s)									{if (!f) throw new PostconditionException(s);}
				public static void Post&lt;A1&gt;(bool f, string format, A1 arg1)					{if (!f) throw new PostconditionException(string.Format(format, arg1));}
				public static void Post&lt;A1, A2&gt;(bool f, string format, A1 arg1, A2 arg2)	{if (!f) throw new PostconditionException(string.Format(format, arg1, arg2));}
				public static void Post(bool f, string format, params object[] args)		{if (!f) throw new PostconditionException(string.Format(format, args));}
			
				public static void Assert(bool f, string s)									{if (!f) throw new AssertException(s);}
				public static void Assert&lt;A1&gt;(bool f, string format, A1 arg1)				{if (!f) throw new AssertException(string.Format(format, arg1));}
				public static void Assert&lt;A1, A2&gt;(bool f, string format, A1 arg1, A2 arg2)	{if (!f) throw new AssertException(string.Format(format, arg1, arg2));}
				public static void Assert(bool f, string format, params object[] args)		{if (!f) throw new AssertException(string.Format(format, args));}
			
				public static void Fail(string s)											{throw new AssertException(s);}
				public static void Fail&lt;A1&gt;(string format, A1 arg1)							{throw new AssertException(string.Format(format, arg1));}
				public static void Fail&lt;A1, A2&gt;(string format, A1 arg1, A2 arg2)			{throw new AssertException(string.Format(format, arg1, arg2));}
				public static void Fail(string format, params object[] args)				{throw new AssertException(string.Format(format, args));}
			
				[Conditional("DEBUG")]
				public static void FastPre(bool f, string s)									{if (!f) throw new PreconditionException(s);}
				[Conditional("DEBUG")]
				public static void FastPre&lt;A1&gt;(bool f, string format, A1 arg1)					{if (!f) throw new PreconditionException(string.Format(format, arg1));}
				[Conditional("DEBUG")]
				public static void FastPre&lt;A1, A2&gt;(bool f, string format, A1 arg1, A2 arg2)		{if (!f) throw new PreconditionException(string.Format(format, arg1, arg2));}
				[Conditional("DEBUG")]
				public static void FastPre(bool f, string format, params object[] args)			{if (!f) throw new PreconditionException(string.Format(format, args));}
			
				[Conditional("DEBUG")]
				public static void FastPost(bool f, string s)									{if (!f) throw new PostconditionException(s);}
				[Conditional("DEBUG")]
				public static void FastPost&lt;A1&gt;(bool f, string format, A1 arg1)					{if (!f) throw new PostconditionException(string.Format(format, arg1));}
				[Conditional("DEBUG")]
				public static void FastPost&lt;A1, A2&gt;(bool f, string format, A1 arg1, A2 arg2)	{if (!f) throw new PostconditionException(string.Format(format, arg1, arg2));}
				[Conditional("DEBUG")]
				public static void FastPost(bool f, string format, params object[] args)		{if (!f) throw new PostconditionException(string.Format(format, args));}
			
				[Conditional("DEBUG")]
				public static void FastAssert(bool f, string s)									{if (!f) throw new AssertException(s);}
				[Conditional("DEBUG")]
				public static void FastAssert&lt;A1&gt;(bool f, string format, A1 arg1)				{if (!f) throw new AssertException(string.Format(format, arg1));}
				[Conditional("DEBUG")]
				public static void FastAssert&lt;A1, A2&gt;(bool f, string format, A1 arg1, A2 arg2)	{if (!f) throw new AssertException(string.Format(format, arg1, arg2));}
				[Conditional("DEBUG")]
				public static void FastAssert(bool f, string format, params object[] args)		{if (!f) throw new AssertException(string.Format(format, args));}
			
				[Conditional("DEBUG")]
				public static void FastFail(string s)											{throw new AssertException(s);}
				[Conditional("DEBUG")]
				public static void FastFail&lt;A1&gt;(string format, A1 arg1)							{throw new AssertException(string.Format(format, arg1));}
				[Conditional("DEBUG")]
				public static void FastFail&lt;A1, A2&gt;(string format, A1 arg1, A2 arg2)			{throw new AssertException(string.Format(format, arg1, arg2));}
				[Conditional("DEBUG")]
				public static void FastFail(string format, params object[] args)				{throw new AssertException(string.Format(format, args));}
			}
			</CSharp>
		</Translation>
	</Violation>

	<Violation checkID = "R1035" severity = "Warning" breaking = "false">
		<Translation lang = "en" typeName = "ValidateArgs2" category = "Reliability">			
			<Cause>
			A method with internal visibility has a reference argument, and 
			a method on that argument is called without first comparing the argument against
			null. Note that this rule is disabled by default.
			</Cause>
		
			<Description>
			A method can be thought of as having a (possibly implicit) contract between
			itself and its caller. The method guarantees that it will do its job when
			called correctly. To check that the contract isn't violated the method
			verifies its arguments and possibly other state when it is entered, if all
			is well it then does its work, and on exit verifies that its work was done.
			See &lt;http://archive.eiffel.com/doc/manuals/technology/contract/&gt; for
			more details.
			
			Normally an exception should be thrown if a reference argument is null so
			that the error can be caught as soon as possible and so that the source of
			the error can be clearly identified. If it may be null there should still
			be a test against null before calling a method on the argument.
			</Description>
	
			<Fix>
			Use a custom assert method, use an if statement and ArgumentNullException, or
			use System.Diagnostics.Debug.Assert (although this last one is iffy because
			it's compiled out in release).
			</Fix>
	
			<CSharp>
			using System.Collections.Generic;
			using System.Diagnostics;
			using System.Runtime.Serialization;
			
			public static class ListExtensions 
			{
				// This is the way arguments are usually checked.
				public static T Back1&lt;T&gt;(this List&lt;T&gt; list) 
				{ 
					if (list == null)
						throw new ArgumentNullException("list");
					
					if (list.Count == 0)
						throw new ArgumentException("list is empty");
					
					return list[list.Count - 1];
				} 
			
				// Some people do this, but the checks are compiled out in release
				// which is especially bad for externally visible methods.
				public static T Back2&lt;T&gt;(this List&lt;T&gt; list) 
				{ 
					Debug.Assert(list != null, "list is null");
					Debug.Assert(list.Count &gt; 0, "list is empty");
					
					return list[list.Count - 1];
				} 
			
				// This uses custom assert methods which are not compiled out in
				// release (see below).
				public static T Back3&lt;T&gt;(this List&lt;T&gt; list) 
				{ 
					DBC.Pre(list != null, "list is null");
					DBC.Pre(list.Count &gt; 0, "list is empty");
					
					return list[list.Count - 1];
				} 
			}
			
			// --------------------------------------------------------
			
			/// &lt;summary&gt;Thrown by Dbc.Assert and FastAssert.&lt;/summary&gt;
			public class AssertException : Exception
			{
				public AssertException(string text) : base(text) 
				{
				}
			
				protected AssertException(SerializationInfo info, StreamingContext context) : base(info, context)
				{
				}
			}
			
			/// &lt;summary&gt;Thrown by Dbc.Pre and FastPre.&lt;/summary&gt;
			public class PreconditionException : AssertException
			{
				public PreconditionException(string text) : base(text) 
				{
				}
			
				protected PreconditionException(SerializationInfo info, StreamingContext context) : base(info, context)
				{
				}
			}
			
			/// &lt;summary&gt;Thrown by Dbc.Post and FastPost.&lt;/summary&gt;
			public class PostconditionException : AssertException
			{
				public PostconditionException(string text) : base(text) 
				{
				}
			
				protected PostconditionException(SerializationInfo info, StreamingContext context) : base(info, context)
				{
				}
			}
			
			/// &lt;summary&gt;Asserts used to verify the contract between the caller of
			/// a method and the method.&lt;/summary&gt;
			///
			/// &lt;remarks&gt;&lt;para&gt;In the Design By Contract methodology methods act as a contract 
			/// between the caller of the method and the method itself. The client guarantees
			/// to call the method correctly and the method guarantees to some work
			/// if called correctly (or throw an exception if it is unable to do so).&lt;/para&gt;
			///
			/// &lt;para&gt;The client side of the contract is checked by the Dbc.Pre methods. The
			/// method side of the contract is checked with Dbc.Post methods. The Dbc.
			/// Assert methods can be used to verify that the state of the world is as
			/// expected within a method. There are also Fast versions of these methods
			/// which are compiled out in release. These should only be used for code
			/// that is known to be time critical.&lt;/para&gt;
			///
			/// &lt;para&gt;Dbc also makes use of invariants, but these are outside the scope of the
			/// Dbc class. See http://archive.eiffel.com/doc/manuals/technology/contract/
			/// for more details.&lt;/para&gt;&lt;/remarks&gt;
			public static class Dbc
			{		
				public static void Pre(bool f, string s)									{if (!f) throw new PreconditionException(s);}
				public static void Pre&lt;A1&gt;(bool f, string format, A1 arg1)					{if (!f) throw new PreconditionException(string.Format(format, arg1));}
				public static void Pre&lt;A1, A2&gt;(bool f, string format, A1 arg1, A2 arg2)		{if (!f) throw new PreconditionException(string.Format(format, arg1, arg2));}
				public static void Pre(bool f, string format, params object[] args)			{if (!f) throw new PreconditionException(string.Format(format, args));}
			
				public static void Post(bool f, string s)									{if (!f) throw new PostconditionException(s);}
				public static void Post&lt;A1&gt;(bool f, string format, A1 arg1)					{if (!f) throw new PostconditionException(string.Format(format, arg1));}
				public static void Post&lt;A1, A2&gt;(bool f, string format, A1 arg1, A2 arg2)	{if (!f) throw new PostconditionException(string.Format(format, arg1, arg2));}
				public static void Post(bool f, string format, params object[] args)		{if (!f) throw new PostconditionException(string.Format(format, args));}
			
				public static void Assert(bool f, string s)									{if (!f) throw new AssertException(s);}
				public static void Assert&lt;A1&gt;(bool f, string format, A1 arg1)				{if (!f) throw new AssertException(string.Format(format, arg1));}
				public static void Assert&lt;A1, A2&gt;(bool f, string format, A1 arg1, A2 arg2)	{if (!f) throw new AssertException(string.Format(format, arg1, arg2));}
				public static void Assert(bool f, string format, params object[] args)		{if (!f) throw new AssertException(string.Format(format, args));}
			
				public static void Fail(string s)											{throw new AssertException(s);}
				public static void Fail&lt;A1&gt;(string format, A1 arg1)							{throw new AssertException(string.Format(format, arg1));}
				public static void Fail&lt;A1, A2&gt;(string format, A1 arg1, A2 arg2)			{throw new AssertException(string.Format(format, arg1, arg2));}
				public static void Fail(string format, params object[] args)				{throw new AssertException(string.Format(format, args));}
			
				[Conditional("DEBUG")]
				public static void FastPre(bool f, string s)									{if (!f) throw new PreconditionException(s);}
				[Conditional("DEBUG")]
				public static void FastPre&lt;A1&gt;(bool f, string format, A1 arg1)					{if (!f) throw new PreconditionException(string.Format(format, arg1));}
				[Conditional("DEBUG")]
				public static void FastPre&lt;A1, A2&gt;(bool f, string format, A1 arg1, A2 arg2)		{if (!f) throw new PreconditionException(string.Format(format, arg1, arg2));}
				[Conditional("DEBUG")]
				public static void FastPre(bool f, string format, params object[] args)			{if (!f) throw new PreconditionException(string.Format(format, args));}
			
				[Conditional("DEBUG")]
				public static void FastPost(bool f, string s)									{if (!f) throw new PostconditionException(s);}
				[Conditional("DEBUG")]
				public static void FastPost&lt;A1&gt;(bool f, string format, A1 arg1)					{if (!f) throw new PostconditionException(string.Format(format, arg1));}
				[Conditional("DEBUG")]
				public static void FastPost&lt;A1, A2&gt;(bool f, string format, A1 arg1, A2 arg2)	{if (!f) throw new PostconditionException(string.Format(format, arg1, arg2));}
				[Conditional("DEBUG")]
				public static void FastPost(bool f, string format, params object[] args)		{if (!f) throw new PostconditionException(string.Format(format, args));}
			
				[Conditional("DEBUG")]
				public static void FastAssert(bool f, string s)									{if (!f) throw new AssertException(s);}
				[Conditional("DEBUG")]
				public static void FastAssert&lt;A1&gt;(bool f, string format, A1 arg1)				{if (!f) throw new AssertException(string.Format(format, arg1));}
				[Conditional("DEBUG")]
				public static void FastAssert&lt;A1, A2&gt;(bool f, string format, A1 arg1, A2 arg2)	{if (!f) throw new AssertException(string.Format(format, arg1, arg2));}
				[Conditional("DEBUG")]
				public static void FastAssert(bool f, string format, params object[] args)		{if (!f) throw new AssertException(string.Format(format, args));}
			
				[Conditional("DEBUG")]
				public static void FastFail(string s)											{throw new AssertException(s);}
				[Conditional("DEBUG")]
				public static void FastFail&lt;A1&gt;(string format, A1 arg1)							{throw new AssertException(string.Format(format, arg1));}
				[Conditional("DEBUG")]
				public static void FastFail&lt;A1, A2&gt;(string format, A1 arg1, A2 arg2)			{throw new AssertException(string.Format(format, arg1, arg2));}
				[Conditional("DEBUG")]
				public static void FastFail(string format, params object[] args)				{throw new AssertException(string.Format(format, args));}
			}
			</CSharp>
		</Translation>
	</Violation>

	<Violation checkID = "R1036" severity = "Warning" breaking = "false">
		<Translation lang = "en" typeName = "ObjectDisposedException" category = "Reliability">			
			<Cause>
			A System.ObjectDisposedException object was constructed with a string literal for
			the first argument.
			</Cause>
		
			<Description>
			ObjectDisposedException takes the name of the object and constructs a message
			using that name and the current culture. To make maintenance simpler the name
			should be constructed using code like: GetType().Name.
			
			If you want to use your own message then use the constructor which takes two
			strings.
			</Description> 
	
			<Fix>
			Use GetType().Name instead of a string literal or use the two string constructor.
			</Fix>
		</Translation>
	</Violation>

	<Violation checkID = "R1037" severity = "Warning" breaking = "false">
		<Translation lang = "en" typeName = "RecursiveLock1" category = "Reliability">			
			<Cause>
			A method acquires a lock and calls another method on the same object which
			acquires the same lock.
			</Cause>
		
			<Description>
			Relying on recursive locks can make threaded code easier to write, but it also
			blurs the boundaries between threaded and serialized code which can lead to 
			subtle bugs, especially as the code evolves. 
			
			Locks can be considered to be a mechanism for preserving class invariants in
			the presence of threading. When a lock is entered the object should be in a 
			consistent state so that the code may safely operate on the object, while the
			lock is held the object may transition to a state where the invariant does not
			hold, but when the lock exits the invariant should be restored. But recursive locks
			muddy this picture and make it more difficult to verify that the code is correct.
			
			There are two places where recursive locks are especially dangerous. The first is
			if the monitor pattern is used with a lock which has already been acquired. When
			Monitor::Wait is called both locks will be released. This can lead to unexpected
			results because now any thread can mutate the object even though the first lock
			was never explicitly released.
			
			The second involves a call to an event or delegate while a lock is held. This is
			a very bad idea in general, because there is no way to know what this code is
			doing. It may block indefinitely, it may try to acquire a lock held by another
			thread and deadlock, or it may call back into our object when its invariant does
			not hold. 
			</Description> 
	
			<Fix>
			Restructure the code so that the public methods only call private methods and
			the public methods are the only methods that lock. Also avoid calling delegates
			or events while holding a lock.
			</Fix>
		</Translation>
	</Violation>

	<Violation checkID = "R1038" severity = "Warning" breaking = "false">
		<Translation lang = "en" typeName = "RecursiveLock2" category = "Reliability">			
			<Cause>
			A delegate is called or an event is fired while a lock is held.
			</Cause>
		
			<Description>
			It's very important to understand what the code is doing when a lock is held.
			If you allow arbitrary code to execute under a lock then it's very difficult 
			to analyze the code for correctness which can open the door to deadlocks or
			subtle reentrancy problems.
			
			Locks can be considered to be a mechanism for preserving class invariants in
			the presence of threading. When a lock is entered the object should be in a 
			consistent state so that the code may safely operate on the object, while the
			lock is held the object may transition to a state where the invariant does not
			hold, but when the lock exits the invariant should be restored. 
			
			If you do allow arbitrary code to be called while a lock is held then you 
			must be prepared to handle reentrant calls. This means that locks must be
			recursive and any public method may be called while a lock is held. It's
			certainly possible to implement such code correctly, but it's fragile and
			can easily break as the code evolves.
			</Description> 
	
			<Fix>
			Don't allow arbitrary code to execute from within locks. If you do allow this
			then document that the class invariant must hold when the external code is called
			and that the external code must be very careful about acquiring other locks.
			</Fix>
		</Translation>
	</Violation>
</Violations>
